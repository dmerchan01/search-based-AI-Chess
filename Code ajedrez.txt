' DEFINICIÓN DE RUTAS Y CONSTANTES 
#define PATH_BASE "X:/EpsonRC70/Projects/chess_arm_robot/"

' VARIABLES GLOBALES 
Global Real g_ZSafe       ' Altura segura de viaje (fija)
Global Real g_U, g_V, g_W
Global Integer iFileNum

' VARIABLES PARA DATOS (Incluye Z ahora) 
Global Real g_ParseX, g_ParseY, g_ParseZ
Global Real g_PathX(20), g_PathY(20), g_PathZ(20)

Function ajedrez
    ' CONFIGURACIÓN INICIAL DEL ROBOT 
    Motor On
    Power High
    Speed 50
    Accel 50, 50
    
    ' Definición de altura segura (para viajar por el aire)
    g_ZSafe = 210.0
    
    ' Orientación fija (6 ejes)
    g_U = 134.3
    g_V = 0.75
    g_W = 179.6
       
    Off 9 ' Gripper abierto

    Print "Sistema listo. Esperando archivos de Python..."

    ' BUCLE PRINCIPAL DE ESCUCHA     Do
        ' 1. Caso MOVE
        If FileExists(PATH_BASE + "move.txt") Then
            Print "Detectado: move.txt"
            Call ReadAndExecute(PATH_BASE + "move.txt", 0)
        
        ' 2. Caso CAPTURE
        ElseIf FileExists(PATH_BASE + "capture.txt") Then
            Print "Detectado: capture.txt"
            Call ReadAndExecute(PATH_BASE + "capture.txt", 1)
            
        ' 3. Caso PROMOTION
        ElseIf FileExists(PATH_BASE + "promotion.txt") Then
            Print "Detectado: promotion.txt"
            ' Reutilizamos la lógica de captura
            Call ReadAndExecute(PATH_BASE + "promotion.txt", 2)
   
        ' 4. Caso CAPTURE_PROMOTION
        ElseIf FileExists(PATH_BASE + "capture_promotion.txt") Then
            Print "Detectado: capture_promotion.txt"
            Call ReadAndExecute(PATH_BASE + "capture_promotion.txt", 3)
        EndIf
        
        Wait 0.2
    Loop
Fend

' -------------------------------------------------------
' FUNCIÓN DE LECTURA Y DESPACHO
' -------------------------------------------------------
Function ReadAndExecute(filePath$ As String, type As Integer)
    Integer fNum
    String data$
    Integer count
    
    fNum = FreeFile
    
    ' Abre el archivo directamente
    ROpen filePath$ As #fNum
    
    count = 0
    Do While Not Eof(fNum)
        Line Input #fNum, data$
        
        ' Llama al parser que ahora extrae X, Y y Z
        Call ParseLine(data$)
        
        g_PathX(count) = g_ParseX
        g_PathY(count) = g_ParseY
        g_PathZ(count) = g_ParseZ ' Guardamos la Z específica (143 o 118)
        
        count = count + 1
        If count > 19 Then Exit Do
    Loop
    
    Close #fNum
    Del filePath$
    
    Print "Puntos leidos: ", count
    
    ' --- SELECCIÓN DE ESTRATEGIA ---
    Select type
        Case 0
            Call Logic_Move
        Case 1
            Call Logic_Capture(count)
        Case 2
        	Call Logic_Capture(count)
        Case 3
            Call Logic_CapProm(count)
    Send
Fend

' ------------------------------------------
' LÓGICA 0: MOVER (Origen -> Destino)
' -------------------------------------------
Function Logic_Move
    Print "Ejecutando Move..."
    Call PickPlace(0, 1)
    Print "Fin Move"
Fend

' ---------------------------------------------
' LÓGICA 1 y 2: CAPTURA / PROMOCIÓN
' ---------------------------------------------
Function Logic_Capture(numPoints As Integer)
    If numPoints < 4 Then
        Print "Error: Faltan coordenadas (Min 4)."
        Exit Function
    EndIf

    Print "Fase 1: Retirando pieza..."
    Call PickPlace(0, 1)
    
    Print "Fase 2: Colocando pieza..."
    Call PickPlace(2, 3)
    
    Print "Operación finalizada."
Fend

' --------------------------------
' LÓGICA 3: CAPTURA + PROMOCIÓN
' --------------------------------
Function Logic_CapProm(numPoints As Integer)
    If numPoints < 6 Then
        Print "Error: Faltan coordenadas para Cap+Prom (Min 6)."
        Exit Function
    EndIf
    
    Print "Fase 1: Retirando pieza enemiga..."
    Call PickPlace(0, 1)
    
    Print "Fase 2: Retirando peón propio..."
    Call PickPlace(2, 3)
    
    Print "Fase 3: Ingresando Dama..."
    Call PickPlace(4, 5)
    
    Print "Captura con Promoción finalizada."
Fend

'-------------------------------------------
' HELPER: PICK & PLACE (Con Z Dinámica)
'-------------------------------------------
Function PickPlace(idxFrom As Integer, idxTo As Integer)
    ' --- RECOGER (PICK) ---
    ' 1. Ir a Origen ARRIBA (Usamos g_ZSafe fija)
    Go XY(g_PathX(idxFrom), g_PathY(idxFrom), g_ZSafe, g_U, g_V, g_W)
    
    ' 2. Bajar a Origen (Usamos g_PathZ específica del archivo)
    Move XY(g_PathX(idxFrom), g_PathY(idxFrom), g_PathZ(idxFrom), g_U, g_V, g_W)
    
    On 9 ' Cerrar
    Wait 1
    
    ' 3. Subir (Volver a g_ZSafe)
    Move XY(g_PathX(idxFrom), g_PathY(idxFrom), g_ZSafe, g_U, g_V, g_W)
    
    ' --- DEJAR (PLACE) ---
    ' 4. Ir a Destino ARRIBA
    Go XY(g_PathX(idxTo), g_PathY(idxTo), g_ZSafe, g_U, g_V, g_W)
    
    ' 5. Bajar a Destino (Usamos g_PathZ específica del archivo)
    Move XY(g_PathX(idxTo), g_PathY(idxTo), g_PathZ(idxTo), g_U, g_V, g_W)
    
    Off 9 ' Abrir
    Wait 1
    
    ' 6. Subir (Finalizar en g_ZSafe)
    Move XY(g_PathX(idxTo), g_PathY(idxTo), g_ZSafe, g_U, g_V, g_W)
Fend

' -----------------------------------------
' PARSER  (Lee X, Y, Z)
' Separa el string: "100.5, 200.5, 143.0"
' -----------------------------------------
Function ParseLine(lineIn$ As String)
    Integer comma1, comma2
    String sX$, sY$, sZ$, remainder$
    
    ' 1. Buscar primera coma (Fin de X)
    comma1 = InStr(lineIn$, ",")
    
    If comma1 > 0 Then
        sX$ = Left$(lineIn$, comma1 - 1)
        
        ' Lo que queda a la derecha de la primera coma
        remainder$ = Mid$(lineIn$, comma1 + 1)
        
        ' 2. Buscar segunda coma (Fin de Y)
        comma2 = InStr(remainder$, ",")
        
        If comma2 > 0 Then
            sY$ = Left$(remainder$, comma2 - 1)
            sZ$ = Mid$(remainder$, comma2 + 1)
            
            ' Guardar en globales
            g_ParseX = Val(sX$)
            g_ParseY = Val(sY$)
            g_ParseZ = Val(sZ$)
        Else
            ' Si no encuentra segunda coma, asumimos que no vino Z (error o formato viejo)
            Print "Error Formato Z: " + lineIn$
            g_ParseZ = 0 ' O un valor por defecto seguro
        EndIf
    Else
        Print "Error Formato X,Y: " + lineIn$
        g_ParseX = 0
        g_ParseY = 0
        g_ParseZ = 0
    EndIf
Fend